{"meta":{"title":"喜欢胖达的阿紫","subtitle":"","description":"招待不周","author":"慕紫无情","url":"https://muziwuqing.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-02-29T09:03:30.000Z","updated":"2020-03-01T08:05:16.062Z","comments":false,"path":"tags/index.html","permalink":"https://muziwuqing.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-02-29T13:53:47.000Z","updated":"2020-03-03T06:24:49.927Z","comments":false,"path":"about/index.html","permalink":"https://muziwuqing.github.io/about/index.html","excerpt":"","text":"二里半皇家女子学院 寂寞的编程小菜鸟 感谢您的访问"},{"title":"categories","date":"2020-02-29T09:06:56.000Z","updated":"2020-03-01T08:05:35.857Z","comments":false,"path":"categories/index.html","permalink":"https://muziwuqing.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-02-29T11:10:42.000Z","updated":"2020-03-05T06:50:16.415Z","comments":false,"path":"friendlinks/index.html","permalink":"https://muziwuqing.github.io/friendlinks/index.html","excerpt":"","text":"友链列表&emsp;&emsp;以下排名不分先后，欢迎访问(～￣▽￣)～ 十七哟 与人无语的博客"}],"posts":[{"title":"Python自学记录","slug":"Python知识点笔记","date":"2020-03-06T10:19:30.000Z","updated":"2020-03-06T10:31:46.670Z","comments":true,"path":"2020/03/06/Python知识点笔记/","link":"","permalink":"https://muziwuqing.github.io/2020/03/06/Python%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/","excerpt":"Python自学记录 学习来自:阿里云大学/通用技术 /Python /Python语言基础1：语法入门网站链接.","text":"Python自学记录 学习来自:阿里云大学/通用技术 /Python /Python语言基础1：语法入门网站链接. 数据类型​ 数据类型指的就是值的类型，也就是可以为变量赋哪些值 数值123456# 笔记 #在Python中，数值分为整数，浮点数(小数)，复数在Python中所有的整数都是int型在Python中所有的小数都是float型Python中的整数的大小没有限制，可以是一个无限大的整数如果数字过大可以使用下划线作为分隔符 ​ 十进制的数不能以0开头 ​ 二进制以0b开头 ​ 八进制以0o开头 ​ 十六进制以0x开头 字符串123456789101112# 笔记 #字符串用来表示一段文本信息，字符串是程序中使用最多的数据类型在Python中字符串需要引号引起来，不使用不是字符串引号可以是单引号也可以是双引号相同的引号不能嵌套使用长字符串的引号不能跨行使用(引号只会在本行找另一个引号)，但可以用反斜杠&quot;\\&quot;切割片段(此方法不会保留引号中字符串的格式)可以使用三重引号来表示一个长字符串，三重引号可以换行，并且会保留字符串中的格式可以使用反斜杠“\\”转义字符 \\uxxxx \\&#39;和\\&quot; \\t 制表符(Tab键) \\n 换行 格式化字符串12345678910# 笔记 #字符串之间也可以进行加法运算如果将两个字符串进行相加，则会自动将两个字符串拼接为一个字符串不能和其他的类型进行加法运算，如果做了会出现异常 TypeError: must be str, not int在创建字符串时，可以在字符串中指定占位符： %s 在字符串中表示任意字符 %f 浮点数占位符 %d 整数占位符格式化字符串，可以通过在字符串前添加一个f来创建一个格式化字符串，在格式化字符串中可以直接嵌入变量 12345678910111213141516# 代码 ##以下全为例子a = 'hello'a = 'abc' + 'haha' + '哈哈'print('a =',a)b = 'Hello %s'%'孙悟空'b = 'hello %s 你好 %s'%('tom','孙悟空')b = 'hello %3.5s'%'abcdefg' # %3.5s字符串的长度限制在3-5之间b = 'hello %s'%123.456b = 'hello %.2f'%123.456b = 'hello %d'%123.95b = '呵呵'print('a = %s'%a)c = f'hello &#123;a&#125; &#123;b&#125;'print(f'a = &#123;a&#125;') 1234567891011121314# 笔记 ## 创建一个变量来保存你的名字name = '孙悟空'# 使用四种方式来输出，欢迎 xxx 光临# 拼串print('欢迎 '+name+' 光临！')# 多个参数print('欢迎',name,'光临！')# 占位符print('欢迎 %s 光临！'%name)# 格式化字符串print(f'欢迎 &#123;name&#125; 光临！') 字符串复制12345# 笔记 #将字符串和数字相乘“*” 在语言中表示乘法“*” 如果将字符串和数字相乘，则解释器会将字符串重复指定的次数并返回 布尔值与空值1234# 笔记 #布尔值（bool），布尔值主要用来做逻辑判断，布尔值一共有两个 True 和 False，True表示真 False表示假None（空值），None专门用来表示不存在 类型检查12345# 笔记 #通过类型检查，可以检查只能值（变量）的类型type()用来检查值的类型该函数会将检查的结果作为返回值返回，可以通过变量来接收函数的返回值 123456789101112# 代码 #a = 123 # 数值b = '123' # 字符串c = type('123')c = type(a)# print(type(b))print(type(1)) # &lt;class 'int'&gt;print(type(1.5)) # &lt;class 'float'&gt;print(type(True)) # &lt;class 'bool'&gt;print(type('hello')) # &lt;class 'str'&gt;print(type(None)) # &lt;class 'NoneType'&gt; 对象12345# 笔记 #python是一门面向对象(object)的编程语言一切皆对象程序运行中，所有的数据都是存储到内存中然后再运行的，对象就是内存中专门用来存储指定数据的一块区域，对象实际上就是一个容器，专门用来存储数据 对象结构1234567891011121314151617181920212223# 笔记 #每个对象都要保存三种数据类型： - id（标识） &gt;id用来识别对象的唯一性，每一个对象都有一个唯一的id &gt;对象的id就相当与人的身份证一样 &gt;可以通过id函数来查看对象的id &gt;id是由解释器产生，在CPython中，id就是对象的内存地址 &gt;对象一旦创建，则它的id永远不能改变 - type（类型） &gt;类型用来标识当前对象所属类型 &gt;比如 int str float bool &gt;类型决定了对象有哪些功能 &gt;通过type()函数来查看对象的类型 &gt;Python是一门强类型语言，对象一旦创建类型便不能修改 -value（值） &gt;值就是对象中存储的具体的数据 &gt;对于有些对象值是可以改变的 &gt;对象分为两大类，可变对象，不可变对象 可变对象的值可以改变 不可变对象的值不可改变 运算符12345678910# 笔记 # - 运算符可以对一个值或多个值进行运算或各种操作 - 比如 + 、-、&#x3D; 都属于运算符 - 运算符的分类： 1.算术运算符 2.赋值运算符 3.比较运算符（关系运算符） 4.逻辑运算符 5.条件运算符（三元运算符） 算数运算符123456789# 笔记 # + 加法运算符（如果是两个字符串之间进行加法运算，则会进行拼串操作） - 减法运算符 * 乘法运算符（如果将字符串和数字相乘，则会对字符串进行复制操作，将字符串重复指定次数） &#x2F; 除法运算符，运算时结果总会返回一个浮点类型 &#x2F;&#x2F; 整除，只会保留计算后的整数位，总会返回一个整型 ** 幂运算，求一个值的几次幂 % 取模，求两个数相除的余数 赋值运算符12345678910# 笔记 #&#x3D; 可以将等号右侧的值赋值给等号左侧的变量+&#x3D; a +&#x3D; 5 相当于 a &#x3D; a + 5-&#x3D; a -&#x3D; 5 相当于 a &#x3D; a - 5&#x3D; a *&#x3D; 5 相当于 a &#x3D; a * 5*&#x3D; a *&#x3D; 5 相当于 a &#x3D; a * 5&#x2F;&#x3D; a &#x2F;&#x3D; 5 相当于 a &#x3D; a &#x2F; 5&#x2F;&#x2F;&#x3D; a &#x2F;&#x2F;&#x3D; 5 相当于 a &#x3D; a &#x2F;&#x2F; 5%&#x3D; a %&#x3D; 5 相当于 a &#x3D; a % 5 关系运算符12345678910111213# 笔记 # 关系运算符用来比较两个值之间的关系，总会返回一个布尔值 如果关系成立，返回True，否则返回False &gt; 比较左侧值是否大于右侧值 &gt;&#x3D; 比较左侧的值是否大于或等于右侧的值 &lt; 比较左侧值是否小于右侧值 &lt;&#x3D; 比较左侧的值是否小于或等于右侧的值 &#x3D;&#x3D; 比较两个对象的值是否相等 !&#x3D; 比较两个对象的值是否不相等 相等和不等比较的是对象的值，而不是id is 比较两个对象是否是同一个对象，比较的是对象的id is not 比较两个对象是否不是同一个对象，比较的是对象的id 逻辑运算符12345678910111213141516171819# 笔记 # 逻辑运算符主要用来做一些逻辑判断 not 逻辑非 not可以对符号右侧的值进行非运算 对于布尔值，非运算会对其进行取反操作，True变False，False变True 对于非布尔值，非运算会先将其转换为布尔值，然后再取反 and 逻辑与 and可以对符号两侧的值进行与运算 只有在符号两侧的值都为True时，才会返回True，只要有一个False就返回False 与运算是找False的 Python中的与运算是短路的与，如果第一个值为False，则不再看第二个值 or 逻辑或 or 可以对符号两侧的值进行或运算 或运算两个值中只要有一个True，就会返回True 或运算是找True的 Python中的或运算是短路的或，如果第一个值为True，则不再看第二个值 条件运算符1234567# 笔记 # 语法： 语句1 if 条件表达式 else 语句2 执行流程： 条件运算符在执行时，会先对条件表达式进行求值判断 如果判断结果为True，则执行语句1，并返回执行结果 如果判断结果为False，则执行语句2，并返回执行结果 常见数据结构列表12345678910# 笔记 #- 列表是Python中的一个对象- 对象（object）就是内存中专门用来存储数据的一块区域- 之前我们学习的对象，像数值，它只能保存一个单一的数据- 列表中可以保存多个有序的数据- 列表是用来存储对象的对象- 列表的使用： 1.列表的创建 2.操作列表中的数据 列表的创建: 123456789101112131415161718192021222324252627282930313233# 代码 ## 创建列表，通过[]来创建列表my_list = [] # 创建了一个空列表print(my_list , type(my_list))# 列表存储的数据，我们称为元素# 一个列表中可以存储多个元素，也可以在创建列表时，来指定列表中的元素my_list = [10] # 创建一个只包含一个元素的列表# 当向列表中添加多个元素时，多个元素之间使用,隔开my_list = [10,20,30,40,50] # 创建了一个保护有5个元素的列表# 列表中可以保存任意的对象my_list = [10,'hello',True,None,[1,2,3],print]# 列表中的对象都会按照插入的顺序存储到列表中，# 第一个插入的对象保存到第一个位置，第二个保存到第二个位置# 我们可以通过索引（index）来获取列表中的元素# 索引是元素在列表中的位置，列表中的每一个元素都有一个索引# 索引是从0开始的整数，列表第一个位置索引为0，第二个位置索引为1，第三个位置索引为2，以此类推my_list = [10,20,30,40,50]# 通过索引获取列表中的元素# 语法：my_list[索引] my_list[0]print(my_list[4])# 如果使用的索引超过了最大的范围，会抛出异常print(my_list[5]) IndexError: list index out of range# 获取列表的长度，列表中元素的个数# len()函数，通过该函数可以获取列表的长度# 获取到的长度的值，是列表的最大索引 + 1print(len(my_list)) # 5 切片 左闭右开 12345678910111213141516171819202122232425262728293031# 代码 ## 切片# 切片指从现有列表中，获取一个子列表# 创建一个列表，一般创建列表时，变量的名字会使用复数stus = ['孙悟空','猪八戒','沙和尚','唐僧','蜘蛛精','白骨精']# 列表的索引可以是负数# 如果索引是负数，则从后向前获取元素，-1表示倒数第一个，-2表示倒数第二个 以此类推print(stus[-2])# 通过切片来获取指定的元素# 语法：列表[起始:结束] # 通过切片获取元素时，会包括起始位置的元素，不会包括结束位置的元素# 做切片操作时，总会返回一个新的列表，不会影响原来的列表# 起始和结束位置的索引都可以省略不写# 如果省略结束位置，则会一直截取到最后# 如果省略起始位置，则会从第一个元素开始截取# 如果起始位置和结束位置全部省略，则相当于创建了一个列表的副本print(stus[1:])print(stus[:3])print(stus[:])print(stus)# 语法：列表[起始:结束:步长] # 步长表示，每次获取元素的间隔，默认值是1print(stus[0:5:3])# 步长不能是0，但是可以是负数print(stus[::0]) ValueError: slice step cannot be zero# 如果是负数，则会从列表的后部向前边取元素print(stus[::-1]) 通用操作123456# 笔记 #+ 和 *in 和 not inlen()min() 和 max() 123456789101112131415161718192021222324252627282930313233343536373839# 代码 ## + 和 *# +可以将两个列表拼接为一个列表my_list = [1,2,3] + [4,5,6]# * 可以将列表重复指定的次数my_list = [1,2,3] * 5print(my_list)# 创建一个列表stus = ['孙悟空','猪八戒','沙和尚','唐僧','蜘蛛精','白骨精','沙和尚','沙和尚']# in 和 not in# in用来检查指定元素是否存在于列表中# 如果存在，返回True，否则返回False# not in用来检查指定元素是否不在列表中# 如果不在，返回True，否则返回Falseprint('牛魔王' not in stus)print('牛魔王' in stus)# len()获取列表中的元素的个数# min() 获取列表中的最小值# max() 获取列表中的最大值arr = [10,1,2,5,100,77]print(min(arr) , max(arr))# 两个方法（method），方法和函数基本上是一样，只不过方法必须通过 对象.方法() 的形式调用# xxx.print() 方法实际上就是和对象关系紧密的函数# s.index() 获取指定元素在列表中的第一次出现时索引print(stus.index('沙和尚'))# index()的第二个参数，表示查找的起始位置 ， 第三个参数，表示查找的结束位置print(stus.index('沙和尚',3,7))# 如果要获取列表中没有的元素，会抛出异常print(stus.index('牛魔王')) ValueError: '牛魔王' is not in list# s.count() 统计指定元素在列表中出现的次数print(stus.count('牛魔王')) 序列123456789101112# 笔记 #- 序列是Python中最基本的一种数据结构- 数据结构指计算机中数据存储的方式- 序列用于保存一组有序的数据，所有的数据在序列当中都有一个唯一的位置（索引） 并且序列中的数据会按照添加的顺序来分配索引- 序列的分类： 可变序列（序列中的元素可以改变）： &gt; 列表（list） 不可变序列（序列中的元素不能改变）： &gt; 字符串（str） &gt; 元组（tuple） 修改列表123456789101112131415161718192021222324252627282930313233# 代码 ## 创建一个列表stus = ['孙悟空','猪八戒','沙和尚','唐僧','蜘蛛精','白骨精']# 修改列表中的元素# 直接通过索引来修改元素stus[0] = 'sunwukong'stus[2] = '哈哈'# 通过del来删除元素del stus[2] # 删除索引为2的元素# 通过切片来修改列表# 在给切片进行赋值时，只能使用序列stus[0:2] = ['牛魔王','红孩儿'] # 使用新的元素替换旧元素stus[0:2] = ['牛魔王','红孩儿','二郎神'] # 这种修改方法可以传多个stus[0:0] = ['牛魔王'] # 向索引为0的位置插入元素# 当设置了步长时，序列中元素的个数必须和切片中元素的个数一致stus[::2] = ['牛魔王','红孩儿','二郎神']# 通过切片来删除元素# del stus[0:2]# del stus[::2]# stus[1:3] = []# print('修改后：',stus)# 以上操作，只适用于可变序列s = 'hello' # 字符串，不可变序列# s[1] = 'a' 不可变序列，无法通过索引来修改# 可以通过 list() 函数将其他的序列转换为lists = list(s)print(s) range1234567891011# 笔记 #range()是一个函数，可以用来生成一个自然数的序列# 该函数需要三个参数# 1.起始位置（可以省略，默认是0）# 2.结束位置# 3.步长（可以省略，默认是1）# 通过range()可以创建一个执行指定次数的for循环# for()循环除了创建方式以外，其余的都和while一样，# 包括else、包括break continue都可以在for循环中使用# 并且for循环使用也更加简单 1234567891011# 代码 #r = range(5) # 生成一个这样的序列[0,1,2,3,4]r = range(0,10,2)r = range(10,0,-1)for i in range(30): print(i)for s in 'hello': print(s) 元组123456# 笔记 #元组是一个不可变的序列它的操作的方式基本上和列表是一致的所以在操作元组时，就把元组当成是一个不可变的列表就ok了一般当我们希望数据不改变时，就使用元组，其余情况都使用列表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 代码 ## 创建元组# 使用()来创建元组my_tuple = () # 创建了一个空元组# print(my_tuple,type(my_tuple)) # &lt;class 'tuple'&gt;my_tuple = (1,2,3,4,5) # 创建了一个5个元素的元组# 元组是不可变对象，不能尝试为元组中的元素重新赋值# my_tuple[3] = 10 TypeError: 'tuple' object does not support item assignment# print(my_tuple[3])# 当元组不是空元组时，括号可以省略# 如果元组不是空元组，它里边至少要有一个,my_tuple = 10,20,30,40my_tuple = 40,# print(my_tuple , type(my_tuple))my_tuple = 10 , 20 , 30 , 40# 元组的解包（解构）# 解包指就是将元组当中每一个元素都赋值给一个变量a,b,c,d = my_tuple# print(\"a =\",a)# print(\"b =\",b)# print(\"c =\",c)# print(\"d =\",d)a = 100b = 300# print(a , b)# 交互a 和 b的值，这时我们就可以利用元组的解包a , b = b , a# print(a , b)my_tuple = 10 , 20 , 30 , 40# 在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致# 也可以在变量前边添加一个*，这样变量将会获取元组中所有剩余的元素a , b , *c = my_tuplea , *b , c = my_tuple*a , b , c = my_tuplea , b , *c = [1,2,3,4,5,6,7]a , b , *c = 'hello world'# 不能同时出现两个或以上的*变量# *a , *b , c = my_tuple SyntaxError: two starred expressions in assignmentprint('a =',a)print('b =',b)print('c =',c) 可变对象1234567891011121314151617181920212223# 笔记 #可变对象是指对象的值可变- 每个对象中都保存了三个数据： id（标识） type（类型） value（值） - 列表就是一个可变对象 a &#x3D; [1,2,3]- a[0] &#x3D; 10 （改对象） - 这个操作是在通过变量去修改对象的值 - 这种操作不会改变变量所指向的对象 - 当我们去修改对象时，如果有其他变量也指向了该对象，则修改也会在其他的变量中体现- a &#x3D; [4,5,6] （改变量） - 这个操作是在给变量重新赋值 - 这种操作会改变变量所指向的对象 - 为一个变量重新赋值时，不会影响其他的变量- 一般只有在为变量赋值时才是修改变量，其余的都是修改对象 123456789101112131415161718192021# 代码 ## 可变对象a = [1,2,3]print('修改前：', a , id(a))# 通过索引修改列表`在这里插入代码片`a[0] = 10print('修改后：', a , id(a))# 为变量重新赋值a = [4,5,6]print('修改后：', a , id(a))a = [1,2,3]b = a # a,b指向的同一个对象，即a，b的id一样b[0] = 10 # 通过改对象b，所有指向该对象的变量的值都变了# b = [10,2,3] # 通过改变量b，b所指向的对象不一样了，修改b，a不会变print(\"a\",a,id(a))print(\"b\",b,id(b)) == 与 is12345# 笔记 # &#x3D;&#x3D; !&#x3D; is is not &#x3D;&#x3D; !&#x3D; 比较的是对象的值是否相等 is is not 比较的是对象的id是否相等（比较两个对象是否是同一个对象） 12345678# 代码 #a = [1,2,3]b = [1,2,3]print(a,b)print(id(a),id(b))print(a == b) # a和b的值相等，使用==会返回Trueprint(a is b) # a和b不是同一个对象，内存地址不同，使用is会返回False 字典123456789101112# 笔记 #- 字典属于一种新的数据结构，称为映射（mapping）- 字典的作用和列表类似，都是用来存储对象的容器- 列表存储数据的性能很好，但是查询数据的性能的很差- 在字典中每一个元素都有一个唯一的名字，通过这个唯一的名字可以快速的查找到指定的元素- 在查询元素时，字典的效率是非常快的- 在字典中可以保存多个对象，每个对象都会有一个唯一的名字 这个唯一的名字，我们称其为键（key），通过key可以快速的查询value 这个对象，我们称其为值（value） 所以字典，我们也称为叫做键值对（key-value）结构 每个字典中都可以有多个键值对，而每一个键值对我们称其为一项（item） 123456789101112131415161718192021222324252627# 代码 ## 字典# 使用 &#123;&#125; 来创建字典d = &#123;&#125; # 创建了一个空字典# 创建一个保护有数据的字典# 语法：# &#123;key:value,key:value,key:value&#125;# 字典的值可以是任意对象# 字典的键可以是任意的不可变对象（int、str、bool、tuple ...），但是一般我们都会使用str# 字典的键是不能重复的，如果出现重复的后边的会替换到前边的# d = &#123;'name':'孙悟空' , 'age':18 , 'gender':'男' , 'name':'sunwukong'&#125;d = &#123;'name':'孙悟空' , 'age':18 , 'gender':'男' , 'name':'sunwukong'&#125;print(d , type(d))# 需要根据键来获取值print(d['name'],d['age'],d['gender'])# 如果使用了字典中不存在的键，会报错print(d['hello']) KeyError: 'hello' 字典的使用创建字典： 1234567891011121314151617# 代码 ## 创建字典# 使用&#123;&#125;# 语法：&#123;k1:v1,k2:v2,k3:v3&#125;# 使用 dict()函数来创建字典# 每一个参数都是一个键值对，参数名就是键，参数名就是值（这种方式创建的字典，key都是字符串）d = dict(name='孙悟空',age=18,gender='男') # 也可以将一个包含有双值子序列的序列转换为字典# 双值序列，序列中只有两个值，[1,2] ('a',3) 'ab'# 子序列，如果序列中的元素也是序列，那么我们就称这个元素为子序列# [(1,2),(3,5)]d = dict([('name','孙悟饭'),('age',18)])# print(d , type(d))d = dict(name='孙悟空',age=18,gender='男') len(): 获取字典中键值对的个数in 和 not in : 检查字典中是否包含(不包含)指定的键d[key] : 获取字典中的值，根据键来获取值get(key[, default]) : 该方法用来根据键来获取字典中的值 12345678910111213141516171819202122# 代码 ## len() 获取字典中键值对的个数print(len(d))# in 检查字典中是否包含指定的键# not in 检查字典中是否不包含指定的键print('hello' in d)# 获取字典中的值，根据键来获取值# 语法：d[key]print(d['age'])# n = 'name'print(d[n])# 通过[]来获取值时，如果键不存在，会抛出异常 KeyError# get(key[, default]) 该方法用来根据键来获取字典中的值# 如果获取的键在字典中不存在，会返回None# 也可以指定一个默认值，来作为第二个参数，这样获取不到值时将会返回默认值print(d.get('name'))print(d.get('hello','默认值')) 修改字典： 12345678910111213141516171819202122# 修改字典# d[key] = value 如果key存在则覆盖，不存在则添加d['name'] = 'sunwukong' # 修改字典的key-valued['address'] = '花果山' # 向字典中添加key-value# print(d)# setdefault(key[, default]) 可以用来向字典中添加key-value# 如果key已经存在于字典中，则返回key的值，不会对字典做任何操作# 如果key不存在，则向字典中添加这个key，并设置valueresult = d.setdefault('name','猪八戒')result = d.setdefault('hello','猪八戒')print('result =',result)print(d)# update([other])# 将其他的字典中的key-value添加到当前字典中# 如果有重复的key，则后边的会替换到当前的d = &#123;'a':1,'b':2,'c':3&#125;d2 = &#123;'d':4,'e':5,'f':6, 'a':7&#125;d.update(d2)# print(d) 删除： 123456# 笔记 #del popitem() : 删除键值对，返回元组，元组中有两个元素，第一个元素是删除的key，第二个是删除的valuepop(key[, default]) : 删除键值对，返回值clear() : 清空字典 123456789101112131415161718192021222324252627282930313233# 代码 ## 删除，可以使用 del 来删除字典中的 key-valuedel d['a']del d['b']# popitem()# 随机删除字典中的一个键值对，一般都会删除最后一个键值对# 删除之后，它会将删除的key-value作为返回值返回# 返回的是一个元组，元组中有两个元素，第一个元素是删除的key，第二个是删除的value# 当使用popitem()删除一个空字典时，会抛出异常 KeyError: 'popitem(): dictionary is empty'# d.popitem()# result = d.popitem()# pop(key[, default])# 根据key删除字典中的key-value# 会将被删除的value返回！# 如果删除不存在的key，会抛出异常# 如果指定了默认值，再删除不存在的key时，不会报错，而是直接返回默认值result = d.pop('d')result = d.pop('z','这是默认值')# del d['z'] z不存在，报错# result = d.popitem()# result = d.popitem()# result = d.popitem()# result = d.popitem()# clear()用来清空字典d.clear()# print('result =',result)# print(d) 复制字典： 1234567891011121314151617# 代码 ## copy()# 该方法用于对字典进行浅复制# 复制以后的对象，和原对象是独立，修改一个不会影响另一个# 注意，浅复制会简单复制对象内部的值，如果值也是一个可变对象，这个可变对象不会被复制d = &#123;'a':1,'b':2,'c':3&#125;d2 = d.copy()# d['a'] = 100d = &#123;'a':&#123;'name':'孙悟空','age':18&#125;,'b':2,'c':3&#125;d2 = d.copy()d2['a']['name'] = '猪八戒' # 修改d2的name，d也会被修改print('d = ',d , id(d))print('d2 = ',d2 , id(d2)) 遍历字典12345# 笔记 #keys(): 返回字典的所有的keyvalue(): 返回一个序列，序列中保存有字典的所有的值item(): 返回一个序列，序列中包含有双值子序列 1234567891011121314151617181920212223# 代码 ## 遍历字典# keys() 该方法会返回字典的所有的key# 该方法会返回一个序列，序列中保存有字典的所有的键d = &#123;'name':'孙悟空','age':18,'gender':'男'&#125;# 通过遍历keys()来获取所有的键for k in d.keys() : print(k , d[k])# values()# 该方法会返回一个序列，序列中保存有字典的所有的值for v in d.values(): print(v)# items()# 该方法会返回字典中所有的项# 它会返回一个序列，序列中包含有双值子序列# 双值分别是，字典中的key和value# print(d.items())for k,v in d.items() : print(k , '=' , v) 集合1234567# 笔记 #- 集合和列表非常相似- 不同点： 1.集合中只能存储不可变对象 2.集合中存储的对象是无序（不是按照元素的插入顺序保存） 3.集合中不能出现重复的元素 集合基本操作1234567891011121314# 笔记 #使用 &#123;&#125; 来创建集合使用 set() 函数来创建集合可以通过set()来将序列和字典转换为集合使用in和not in来检查集合中的元素使用len()来获取集合中元素的数量使用len()来获取集合中元素的数量add() 向集合中添加元素update() 将一个集合中的元素添加到当前集合中pop()随机删除并返回一个集合中的元素remove()删除集合中的指定元素 clear()清空集合copy()对集合进行浅复制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 代码 ## 集合# 使用 &#123;&#125; 来创建集合s = &#123;10,3,5,1,2,1,2,3,1,1,1,1&#125; # &lt;class 'set'&gt;# s = &#123;[1,2,3],[4,6,7]&#125; TypeError: unhashable type: 'list'# 使用 set() 函数来创建集合s = set() # 空集合# 可以通过set()来将序列和字典转换为集合s = set([1,2,3,4,5,1,1,2,3,4,5])s = set('hello')s = set(&#123;'a':1,'b':2,'c':3&#125;) # 使用set()将字典转换为集合时，只会包含字典中的键# 创建集合s = &#123;'a' , 'b' , 1 , 2 , 3 , 1&#125;# 使用in和not in来检查集合中的元素# print('c' in s)# 使用len()来获取集合中元素的数量# print(len(s))# add() 向集合中添加元素s.add(10)s.add(30)# update() 将一个集合中的元素添加到当前集合中# update()可以传递序列或字典作为参数，字典只会使用键s2 = set('hello')s.update(s2)s.update((10,20,30,40,50))s.update(&#123;10:'ab',20:'bc',100:'cd',1000:'ef'&#125;)# &#123;1, 2, 3, 100, 40, 'o', 10, 1000, 'a', 'h', 'b', 'l', 20, 50, 'e', 30&#125;# pop()随机删除并返回一个集合中的元素# result = s.pop()# remove()删除集合中的指定元素s.remove(100)s.remove(1000)# clear()清空集合s.clear()# copy()对集合进行浅复制# print(result)print(s , type(s)) 集合的运算12345678910# 笔记 #&amp;: 交集运算|: 并集运算-: 差集^: 异或集 获取只在一个集合中出现的元素&lt;&#x3D;: 检查一个集合是否是另一个集合的子集&lt;: 检查一个集合是否是另一个集合的真子集&gt;&#x3D;: 检查一个集合是否是另一个的超集&gt;: 检查一个集合是否是另一个的真超集 123456789101112131415161718192021222324252627282930313233343536# 代码 ## 在对集合做运算时，不会影响原来的集合，而是返回一个运算结果# 创建两个集合s = &#123;1,2,3,4,5&#125;s2 = &#123;3,4,5,6,7&#125;# &amp; 交集运算result = s &amp; s2 # &#123;3, 4, 5&#125;# | 并集运算result = s | s2 # &#123;1,2,3,4,5,6,7&#125;# - 差集result = s - s2 # &#123;1, 2&#125;# ^ 异或集 获取只在一个集合中出现的元素result = s ^ s2 # &#123;1, 2, 6, 7&#125;# &lt;= 检查一个集合是否是另一个集合的子集# 如果a集合中的元素全部都在b集合中出现，那么a集合就是b集合的子集，b集合是a集合超集a = &#123;1,2,3&#125;b = &#123;1,2,3,4,5&#125;result = a &lt;= b # Trueresult = &#123;1,2,3&#125; &lt;= &#123;1,2,3&#125; # Trueresult = &#123;1,2,3,4,5&#125; &lt;= &#123;1,2,3&#125; # False# &lt; 检查一个集合是否是另一个集合的真子集# 如果超集b中含有子集a中所有元素，并且b中还有a中没有的元素，则b就是a的真超集，a是b的真子集result = &#123;1,2,3&#125; &lt; &#123;1,2,3&#125; # Falseresult = &#123;1,2,3&#125; &lt; &#123;1,2,3,4,5&#125; # True# &gt;= 检查一个集合是否是另一个的超集# &gt; 检查一个集合是否是另一个的真超集print('result =',result)","categories":[{"name":"python","slug":"python","permalink":"https://muziwuqing.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://muziwuqing.github.io/tags/python/"}]},{"title":"创建完博客的一些感想","slug":"创建完博客的一些感想","date":"2020-03-03T10:03:30.000Z","updated":"2020-03-06T10:31:42.974Z","comments":true,"path":"2020/03/03/创建完博客的一些感想/","link":"","permalink":"https://muziwuqing.github.io/2020/03/03/%E5%88%9B%E5%BB%BA%E5%AE%8C%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/","excerpt":"创建完博客的一些感想​ 这几天沉迷于搭建自己的博客，中间也踩过好多坑，又因为本身对css，js这些不熟，出过好多bug。 ​ 但是每次完成一个小项目就会特别高兴，从刚开始啥都不知道，然后百度出来GitHub pages搭建个人博客的方法，发现了hexo这个快速、简洁且高效的博客框架。","text":"创建完博客的一些感想​ 这几天沉迷于搭建自己的博客，中间也踩过好多坑，又因为本身对css，js这些不熟，出过好多bug。 ​ 但是每次完成一个小项目就会特别高兴，从刚开始啥都不知道，然后百度出来GitHub pages搭建个人博客的方法，发现了hexo这个快速、简洁且高效的博客框架。 第一次 安装环境与在本地主机创建网站​ 第一次搭建网站时，我心惊胆战的照着hexo官网的教程操作，第一次接触这个嘛，非常担心哪个地方操作不当，然后重来。下载hexo前，先安装git和Node.js，然后通过npm输入npm install -g hexo-cli就可以安装hexo框架了。(PS：我本来也不知道npm是啥，后来发现npm是随同NodeJS一起安装的，通过cmd使用就行了。) ​ 安装好hexo之后，跟着官方文档来操作，输入hexo init &lt;folder&gt;就会在folder这个文件夹下新建所需要的文件了。创建完成后，大致会有这几个重要的文件夹和文件夹，如下： 12345678.├── _config.yml #这是站点配置文件，之后很多设置要在这里面进行├── package.json #应用程序的信息，一般不用打开操作里面的文件├── scaffolds #模板文件夹，新建文章时，会根据这里面的模板来建立文件，比如文章的title，date等信息├── source #放用户的资源。除_posts文件夹之外，开头命名为_(下划线)的文件&#x2F;文件夹和隐藏的文件将会被忽略。Markdown(.md)和HTML(.html)文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。| ├── _drafts #草稿，我感觉一般用不上| └── _posts #文章就放在这儿└── themes #主题文件夹。下载好模板后放在这儿。Hexo会根据主题来生成静态页面 ​ 创建好后进入_config.yml文件，然后配置站点信息，具体的配置方法官方文档有，在想要修改的地方，在那个英文命后面修改就行了，看不懂的英文的复制粘贴，然后去网上翻译或者用别的软件翻译。我第一次使用时不知道这个。。。然后网站的title，name这些地方都是用的默认的，我直接在public文件夹里的.html文件改。然后用hexo g生成静态页面时，生成的public文件夹里的网站信息都是从_config.yml这个配置文件里获取的。（PS：一个小巧便捷的桌面翻译软件推荐：copytranslator，这个软件没广告，而且包含谷歌翻译，百度翻译，网易翻译等等，复制要翻译的英文，不用啥别的操作，译文就直接出来了。还有关于编辑.yml之类的文件的软件，网上很多，流行的像notepad++，sublime这些就挺好用的） ​ 右键网站文件夹的根目录，点击Git bash here然后使用hexo cl、hexo g、hexo s，再在浏览器中输入http://localhost:4000/就可以看见自己的网站了（PS：hexo cl是hexo clean的缩写，清除public文件夹及之前的缓存；hexo g是生成静态页面，页面的信息与配置就在生成的public文件夹里；hexo s将网站部署到本地主机上，进行这一步操作后就能打开http://localhost:4000/看见自己的网站了，不然不能访问。 hexo d将在后面用到，这个命令会将网站文件上传至自己的GitHub仓库中，然后就可以在自己的GitHub pages网站上看到自己的博客了）","categories":[{"name":"日记","slug":"日记","permalink":"https://muziwuqing.github.io/categories/%E6%97%A5%E8%AE%B0/"},{"name":"hexo","slug":"日记/hexo","permalink":"https://muziwuqing.github.io/categories/%E6%97%A5%E8%AE%B0/hexo/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://muziwuqing.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"hexo","slug":"hexo","permalink":"https://muziwuqing.github.io/tags/hexo/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2020-02-29T12:38:07.000Z","updated":"2020-03-06T10:30:32.465Z","comments":true,"path":"2020/02/29/我的第一篇博客/","link":"","permalink":"https://muziwuqing.github.io/2020/02/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"这是我的第一篇博克花了两天终于把自己的博客网站建起来了，虽然过程有点小复杂，但感觉还是挺好玩的。","text":"这是我的第一篇博克花了两天终于把自己的博客网站建起来了，虽然过程有点小复杂，但感觉还是挺好玩的。 接下来我要完善博客，之后绑定域名，在博客中添加装饰品。 然后把原本写在CSDN上的一些文章搬运到这里来。","categories":[{"name":"日记","slug":"日记","permalink":"https://muziwuqing.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://muziwuqing.github.io/tags/%E6%97%A5%E8%AE%B0/"}]}]}